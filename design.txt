can restructure commits into a tree way by still having the version numbers as linear, but can be connected to other versions, so can be

V1, V2, V3, V4, V5, V6, .....

V1 --->V2
   |
   |
   --->V3 --->V4 --->V6
          |
          |
          --->V5

And then do serialize/deserialize of nary tree

Solution:
package main

import (
	"encoding/json"
	"fmt"
)

type Node struct {
	Value    string
	Children []*Node
}

func getTree(node *Node) string {
	treeStr := "all commits:\n"
	treeStr += buildTree(node, "", true, true)
	return treeStr
}

func buildTree(node *Node, prefix string, isLastChild bool, isRoot bool) string {
	treeString := ""

	if !isRoot {
		if isLastChild {
			treeString += prefix + "└── "
			prefix += "    "
		} else {
			treeString += prefix + "├── "
			prefix += "|   "
		}
	}

	treeString += node.Value + "\n"

	childCount := len(node.Children)
	for i, child := range node.Children {
		isLast := i == childCount-1
		treeString += buildTree(child, prefix, isLast, false)
	}

	return treeString
}

// Serialize serializes an N-ary tree to a JSON string
func Serialize(root *Node) (string, error) {
	data, err := json.Marshal(root)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

// Deserialize deserializes a JSON string to an N-ary tree
func Deserialize(data string) (*Node, error) {
	var root Node
	err := json.Unmarshal([]byte(data), &root)
	if err != nil {
		return nil, err
	}
	return &root, nil
}

func main() {
	// Create the n-ary tree
	root := &Node{Value: "V1"}
	node2 := &Node{Value: "V2"}
	node3 := &Node{Value: "V3"}
	node4 := &Node{Value: "V4"}
	node5 := &Node{Value: "V5"}
	node6 := &Node{Value: "V6"}

	root.Children = append(root.Children, node2)
	root.Children = append(root.Children, node3)
	node3.Children = append(node3.Children, node5)
	node4.Children = append(node4.Children, node6)
	node3.Children = append(node3.Children, node4)

	// Serialize the tree to JSON
	serialized, err := Serialize(root)
	if err != nil {
		fmt.Println("Serialization error:", err)
		return
	}
	deserialized, err := Deserialize(serialized)
	if err != nil {
		fmt.Println("Deserialization error:", err)
		return
	}
	fmt.Println(getTree(deserialized))
}
